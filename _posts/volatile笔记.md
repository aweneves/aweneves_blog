#### 重排序

概念：编译器可能改变两个操作的先后顺序；处理器可能不是完全依照程序的目标代码所指定的顺序执行指令；另外，一个处理器上执行的多个操作，从其他处理器的角度来看其顺序可能与目标代码所指定的顺序不一致。这种现象就叫作重排序(Reordering)。

重排序是对内存访问有关的操作(读和写)所做的一种优化，它可以在不影响单线程程序正确性的情况下提升程序的性能。但是，它可能对多线程程序的正确性产生影响，即它可能导致线程安全问题。与可见性问题类似，重排序也不是必然出现的。

重排序的潜在来源有许多，包括编译器(在Java平台中这基本上指JIT编译器)、处理器和存储子系统(包括写缓冲器Store Buffer，高速缓存Cache)。为了便于下面的讲解，我们先定义几个与内存操作顺序有关的术语。

- 源代码顺序(Source Code)：源代码中所指定的内存访问操作顺序。
- 程序顺序(Program Order)：在给定处理器上运行的目标代码(Object Code)所指定的内存访问操作顺序。尽管Java虚拟机执行Java代码有两种方式：解释执行(被执行的是字节码Byte Code)和编译执行(被执行的是机器码)。为便于讨论，这里仅将目标代码定义为字节码。
- 执行顺序(Execution Order)：内存访问操作在给定处理器上的实际执行顺序。
- 感知顺序(Perceived Order)：处理器所感知到(看到)的该处理器及其他处理器的内存访问操作发生的顺序。

在此基础上,我们将重排序划分为指令重排序(Instruction Reorder)和存储子系统重排序两种,如下表所示。

![image-20220623111645632](https://raw.githubusercontent.com/aweneves/picgo-image/main/img/image-20220623111645632.png)

##### 指令重排序

1. 在其他编译型语言(如C++)中，编译器是可能导致指令重排序的：编译器出于性能的考虑，在其认为不影响程序(单线程程序)正确性的情况下可能会对源代码顺序进行调整，从而造成程序顺序与相应的源代码顺序不一致。在Java平台中，静态编译器(javac)基本上不会执行指令重排序，而JIT编译器则可能执行指令重排序。

2. 处理器也可能执行指令重排序，这使得执行顺序与程序顺序不一致。处理器对指令进行重排序也被称为处理器的乱序执行( Out-of-order Execution)。现代处理器为了提高指令执行效率，往往不是按照程序顺序逐一执行指令的，而是动态调整指令的顺序，做到哪条指令就绪就先执行哪条指令，这就是处理器的乱序执行。在乱序执行的处理器中，指令是一条一条按照程序顺序被处理器读取的(亦即“顺序读取”)，然后这些指令中哪条就绪了哪条就会先被执行，而不是完全按照程序顺序执行(亦即“乱序执行”)。这些指令执行的结果(要进行写寄存器或者写内存的操作)会被先存入重排序缓冲器(ROB, ReorderBuffer)，而不是直接被写人寄存器或者主内存。重排序缓冲器会将各个指令的执行结果按照相应指令被处理器读取的顺序提交(Commit，即写人)到寄存器或者内存中去(亦即“顺序提交”)。在乱序执行的情况下，尽管指令的执行顺序可能没有完全依照程序顺序，但是由于指令的执行结果的提交(即反映到寄存器和内存中)仍然是按照程序顺序来的，因此处理器的指令重排序并不会对单线程程序的正确性产生影响。

##### 存储子系统重排序

- 指令重排序的重排序对象是指令，它实实在在地对指令的顺序进行调整，而存储子系统重排序是一种现象而不是一种动作，它并没有真正对指令执行顺序进行调整，而只是造成了一种指令的执行顺序像是被调整过一样的现象，其重排序的对象是内存操作的结果。
  习惯上为了便于讨论，在论及内存重排序问题的时候我们往往采用指令重排序的方式来表述，即我们也会用“内存操作X被重排序到内存操作Y之后”这样的表述称呼内存重排序。

内存重排序与具体的处理器微架构有关，基于不同微架构的处理器所允许(或者支持)的内存重排序是不同的，如下表所示。

![image-20220623145147771](https://raw.githubusercontent.com/aweneves/picgo-image/main/img/image-20220623145147771.png)

#### 内存屏障

内存屏障是被插人到两个指令之间进行使用的，其作用是禁止编译器、处理器重排序从而保障有序性。它在指令序列(如后)的指令无法“穿越”它(一旦穿越了就是重排序了)。但是,为了实现禁止重排序的功能，这些指令也往往具有一个副作用-刷新处理器缓存、冲刷处理器缓存,从而保证可见性。

##### 扩展知识

编译期重排序，即静态编译器(对于Java平台指javac)造成的重排序会对运行在单处理器上的多个线程产生影响。运行期重排序，包括存储子系统造成的重排序、JIT编译器造成的重排序以及处理器的乱序执行所导致的重排序,并不会对单处理器上运行的多线程产生影响,即在这些线程

#### volatile写：

![image-20220614194256128](https://raw.githubusercontent.com/aweneves/picgo-image/main/imgimage-20220614194256128.png)



![image-20220614194340087](https://raw.githubusercontent.com/aweneves/picgo-image/main/imgimage-20220614194340087.png)



![image-20220614192432549](https://raw.githubusercontent.com/aweneves/picgo-image/main/imgimgimgimage-20220614192432549.png)




![image-20220614192055348](https://raw.githubusercontent.com/aweneves/picgo-image/main/imgimage-20220614192055348.png)



```
...其他代码
LoadStore
StoreStore
a = 0； // a是volatile变量
StoreLoad
...其他代码
```

> Java虚拟机对内存屏障的使用往往会做一些优化。这些优化包括省略、合并等。例如，对于两个连续的volatile写操作，Java虚拟机可能只在最后一个volatile写操作之后插人StoreLoad屏障，而不是在每个volatile写操作后插入一个StoreLoad屏障。在x86处理器下, Java虚拟机对monitorexit的实现本身就带有StoreLoad屏障的效果,因此Java虚拟机不会在monitorexit对应的机器码指令之后插人StoreLoad屏障。

**保证有序性：**volatile虽然能够保障有序性，但是它不像锁那样具备排他性，所以并不能保障其他操作的原子性，而只能够保障对被修饰变量的写操作的原子性。因此，volatile变量写操作之前的操作如果涉及共享可变变量，那么竞态仍可能产生。这是因为共享变量被赋值给volatile变量的时候其他线程可能已经更新了该共享变量的值。

**保证可见性：**存储屏障具有冲刷处理器缓存的作用，因此在volatile变量写操作之后插人的一个存储屏障(参见图3-6)就使得该存储屏障前所有操作的结果(包括volatile变量写操作及该操作之前的任何操作)对其他处理器来说是可同步的。		



#### volatile读：

![image-20220614194820491](https://raw.githubusercontent.com/aweneves/picgo-image/main/imgimage-20220614194820491.png) 



![image-20220614194756127](https://raw.githubusercontent.com/aweneves/picgo-image/main/imgimage-20220614194756127.png) 

![image-20220614200732285](https://raw.githubusercontent.com/aweneves/picgo-image/main/imgimage-20220614200732285.png) 

![image-20220614194850492](https://raw.githubusercontent.com/aweneves/picgo-image/main/imgimage-20220614194850492.png) 

```
LoadLoad
int a = b； // b是volatile变量
LoadLoad
LoadStore
...其他代码
```

对于volatile变量读操作， Java虚拟机会在该操作之前插人一个加载屏障(LoadBarrier )，并在该操作之后插人一个获取屏障(Acquire Barrier)，如图3-7所示。	

**保证可见性：**加载屏障通过冲刷处理器缓存，使其执行线程(读线程)所在的处理器，将其他处理器对共享变量(可能是多个变量)所做的更新，同步到该处理器的高速缓存中。读线程执行的加载屏障和写线程执行的存储屏障配合在一起，使得写线程对volatile变量的写操作，以及在此之前所执行的其他内存操作的结果对读线程可见，即保障了可见性。因此，volatile不仅仅保障了volatile变量本身的可见性，还保障了写线程在更新volatile变量之前执行的所有操作的结果对读线程可见。这种可见性保障类似于锁对可见性的保障，与锁不同的是volatile不具备排他性，因而它不能保障读线程读取到的这些共享变量的值是最新的，即读线程读取到这些共享变量的那一刻可能已经有其他写线程更新了这些共享变量的值。

**保证有序性：**另外，获取屏障禁止了volatile读操作之后的任何读、写操作与volatile读操作进行重排序。因此它保障了volatile读操作之后的任何操作开始执行之前，写线程对相关共享变量(包，括volatile变量和普通变量)的更新已经对当前线程可见。

**volatile在有序性保障方面也可以从禁止重排序的角度理解，即volatile禁止了如下重排序:**

**写volatile变量操作与该操作之前的任何读、写操作不会被重排序；**

**读volatile变量操作与该操作之后的任何读、写操作不会被重排序。**



#### 数组和引用类型：

如果被修饰的变量是个数组，那么volatile关键字只能够对数组引用本身的操作(读取数组引用和更新数组引用)起作用，而无法对数组元素的操作(读取、更新数组元素)起作用。

如果要使对数组元素的读、写操作也能够触发volatile关键字的作用，那么我们可以使用 AtomiclntegerArray， AtomicLongArray 和 AtomicReferenceArray.

类似地，对于引用型volatile变量，volatile关键字只是保证读线程能够读取到一个指向对象的相对新的内存地址(引用)，而这个内存地址指向的对象的实例/静态变量值是否是相对新的则没有保障。



#### volatile变量的开销

volatile变量的开销包括读变量和写变量两个方面。volatile变量的读、写操作都不会导致上下文切换，因此volatile的开销比锁要小。

写一个volatile变量会使该操作以及该操作之前的任何写操作的结果对其他处理器是可同步的，因此volatile变量写操作的成本介于普通变量的写操作和在临界区内进行的写操作之间。

读取volatile变量的成本也比在临界区中读取变量要低(没有锁的申请与释放以及上下文切换的开销)，但是其成本可能比读取普通变量要高一些。这是因为volatile变量的值每次都需要从高速缓存或者主内存中读取，而无法被暂存在寄存器中，从而无法发挥访问的高效性。



#### volatile使用场景

**场景一: 使用volatile变量作为状态标志。**在该场景中，应用程序的某个状态由一个线程设置，其他线程会读取该状态并以该状态作为其计算的依据(或者仅仅读取并输出这个状态值)。此时使用volatile变量作为同步机制的好处是一个线程能够“通知”另外一个线程某种事件(例如，网络连接断连之后重新连上)的发生，而这些线程又无须因此而使用锁，从而避免了锁的开销以及相关问题。
**场景二: 使用volatile保障可见性。**在该场景中，多个线程共享一个可变状态变量，其中一个线程更新了该变量之后，其他线程在无须加锁的情况下也能够看到该更新。
**场景三: 使用volatile变量替代锁。** volatile关键字并非锁的替代品，但是在一定的条件下它比锁更合适(性能开销小、代码简单)。多个线程共享一组可变状态变量的时候，通常我们需要使用锁来保障对这些变量的更新操作的原子性，以避免产生数据不一致问题。利用volatile变量写操作具有的原子性，我们可以把这一
组可变状态变量封装成一个对象，那么对这些状态变量的更新操作就可以通过创建一个新的对象并将该对象引用赋值给相应的引用型变量来实现。在这个过程中，
volatile保障了原子性和可见性，从而避免了锁的使用。
**场景四: 使用volatile实现简易版读写锁。**在该场景中，读写锁是通过混合使用锁和volatile变量而实现的，其中锁用于保障共享变量写操作的原子性， volatile变量用于保障共享变量的可见性。因此，与ReentrantReadWriteLock所实现的读写锁不同的是，这种简易版读写锁仅涉及一个共享变量并且允许一个线程读取这
个共享变量时其他线程可以更新该变量(这是因为读线程并没有加锁)。因此，这种读写锁允许读线程可以读取到共享变量的非最新值。该场景的一个典型例子
是实现一个计数器，如清单3-7所示。



```
/**
 * 基于双重检查锁定的错误单例模式实现
 **/
public class IncorrectDCLsingletion[
// 保存该类的唯一实例
private static IncorrectDCLsingletion instance = null；
/*
 * 私有构造器使其他类无法直接通过new创建该类的实例
 */
private Incorrect DCLsingletion(){
	//什么也不做
}
/**
 *创建并返回该类的唯一实例
 *即只有该方法被调用时该类的唯一实例才会被创建
 */
public static IncorrectDCLsingletion getInstance() {
	if(null == instance) { // 操作①：第一次检查
		synchronized(IncorrectDCLSingletion.class) {
			if(null == instance) { // 操作②：第二次检查
				instance = new IncorrectDCLsingletion()；	// 操作③ 
			}
		}
	}
	return instance；
}

public void someService(){
	// 省略其他代码
}

```

尽管第1次检查(操作①)对变量instance的访问没有加锁从而使竞态仍然可能存在，但是乍一看，它似乎既避免了锁的开销又保障了线程安全:一个线程T，执行到操作①的时候发现instance为null，而此刻另外一个线程T2可能恰好刚执行完操作③而使instance值不为null；接着T，获得锁而执行临界区代码的时候会再次判断 instance值是否为null(第2次检查)，此时由于该线程是在临界区内读取共享变量instance的，因此T可以发现此刻instance值已经不为null，于是，T不会操作③(创建实例)，从而避免了再次创建一个实例。当然，仅仅从可见性的角度分析结论确实如此。但是，在一些情形下为了确保线程安全光考虑可见性是不够的，我们还需要考虑重排序的因素。我们知道操作③可以分解为以下伪代码所示的几个独立子操作:

```
objRef = allocate (IncorrectDCLsingletion.class): // 子操作①:分配对象所需的存储空间
invokeConstructor (objRef): // 子操作②:初始化 objRef引用的对象
instance= objRef； //子操作③:将对象引用写入共享变量
```

根据锁的重排序规则2和规则1(参见3.7节)，临界区内的操作可以在临界区内被重排序。因此，JIT编译器可能将上述的子操作重排序为:子操作①→子操作③→子操作②，即在初始化对象之前将对象的引用写入实例变量instance(正如我们在第2章清单2-10所示的Demo中所看到的现象)。由于锁对有序性的保障是有条件的(参见3.2.1节)，而操作①(第1次检查)读取instance变量的时候并没有加锁，因此上述重排序对操作①的执行线程是有影响的：该线程可能看到一个未初始化(或未初始化完毕)的实例，即变量instance的值不为null，但是该变量所引用的对象中的某些实例变量的变量值可能仍然是默认值，而不是构造器中设置的初始值。也就是说，一个线程在执行操作①的时候发现instance为null，于是该线程就直接返回这个instance变量所引用的实例，而这个实例可能是未初始化完毕的，这就可能导致程序出错!

在分析清楚问题的原因之后，解决方法也就不难想到：只需要将instance变量采用volatile修饰即可。这实际上是利用了volatile关键字的以下两个作用。
**保障可见性**：一个线程通过执行操作③修改了instance变量值，其他线程可以读取到相应的值(通过执行操作①)。
**保障有序性**：由于volatile能够禁止volatile变量写操作与该操作之前的任何读、写操作进行重排序，因此，用volatile修饰instance相当于禁止JIT编译器以及处
理器将子操作②(对对象进行初始化的写操作)重排序到子操作③(将对象引用写人共享变量的写操作)，这保障了一个线程读取到instance变量所引用的实例时该实例已经初始化完毕。

![image-20220623194744160](https://raw.githubusercontent.com/aweneves/picgo-image/main/img/image-20220623194744160.png)